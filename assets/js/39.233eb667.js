(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{324:function(v,_,e){"use strict";e.r(_);var a=e(10),o=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"理论基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#理论基础"}},[v._v("#")]),v._v(" 理论基础")]),v._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#并发三要素"}},[v._v("并发三要素")])]),_("li",[_("a",{attrs:{href:"#happens-before-规则"}},[v._v("Happens-Before 规则")])]),_("li",[_("a",{attrs:{href:"#线程安全等级"}},[v._v("线程安全等级")])]),_("li",[_("a",{attrs:{href:"#线程安全的实现"}},[v._v("线程安全的实现")])]),_("li",[_("a",{attrs:{href:"#线程的实现"}},[v._v("线程的实现")])]),_("li",[_("a",{attrs:{href:"#线程基础使用"}},[v._v("线程基础使用")]),_("ul",[_("li",[_("a",{attrs:{href:"#线程同步互斥"}},[v._v("线程同步互斥")])])])]),_("li",[_("a",{attrs:{href:"#java锁"}},[v._v("Java锁")])])])]),_("p"),v._v(" "),_("h2",{attrs:{id:"并发三要素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发三要素"}},[v._v("#")]),v._v(" 并发三要素")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("可见性")]),v._v(": CPU缓存, 不同线程对一个变量的修改其他线程不能马上看到, 而是先修改线程自身的缓存")]),v._v(" "),_("li",[_("code",[v._v("原子性")]),v._v(": 一行代码含有的多个操作无法保证绝对连续执行, 涉及地址多次操作(如"),_("code",[v._v("x = y, x++")]),v._v(")一般不保证原子性")]),v._v(" "),_("li",[_("code",[v._v("有序性")]),v._v(": 代码经JVM优化后会发生指令重排, 进而可能导致可见性问题")])]),v._v(" "),_("h2",{attrs:{id:"happens-before-规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#happens-before-规则"}},[v._v("#")]),v._v(" Happens-Before 规则")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("单一线程原则")]),v._v(": 一个线程内, 程序前面操作先于后面操作")]),v._v(" "),_("li",[_("code",[v._v("管程锁定规则")]),v._v(": unlock先于对同一个锁的lock")]),v._v(" "),_("li",[_("code",[v._v("volatile变量规则")]),v._v(": volatile变量的写操作先于读操作")]),v._v(" "),_("li",[_("code",[v._v("线程启动规则")]),v._v(": Thread对象的start()先于该线程所有操作")]),v._v(" "),_("li",[_("code",[v._v("线程加入规则")]),v._v(": Thread对象的结束先于join()返回")]),v._v(" "),_("li",[_("code",[v._v("线程中断规则")]),v._v(": 线程interrupt()先于中断线程代码检测到中断事件")]),v._v(" "),_("li",[_("code",[v._v("对象终结规则")]),v._v(": 对象的初始化先于finalize()的开始")]),v._v(" "),_("li",[_("code",[v._v("传递性")]),v._v(": A先于B, B先于C, 则A先于C")])]),v._v(" "),_("h2",{attrs:{id:"线程安全等级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程安全等级"}},[v._v("#")]),v._v(" 线程安全等级")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("不可变")]),v._v(": 一定线程安全")]),v._v(" "),_("li",[_("code",[v._v("绝对线程安全")]),v._v(": 无论运行环境, 无需同步即可保证线程安全")]),v._v(" "),_("li",[_("code",[v._v("相对线程安全")]),v._v(": 对对象单独操作线程安全, 调用无需额外措施, 但是需要代码持续运行需要同步保证调用正确, 如Vector获取元素线程试图访问被删除元素会抛出异常导致无法继续")]),v._v(" "),_("li",[_("code",[v._v("线程兼容")]),v._v(": 对象本身不是线程安全, 但可以通过同步保证线程安全")]),v._v(" "),_("li",[_("code",[v._v("线程对立")]),v._v(": 无论是否同步都无法在多线程中使用")])]),v._v(" "),_("h2",{attrs:{id:"线程安全的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程安全的实现"}},[v._v("#")]),v._v(" 线程安全的实现")]),v._v(" "),_("ul",[_("li",[v._v("使用锁进行互斥同步(阻塞同步)")]),v._v(" "),_("li",[v._v("非阻塞同步:\n"),_("ul",[_("li",[_("code",[v._v("CAS")]),v._v(": 对内存V操作时, 只有当V的值等于A时才会修改为B")]),v._v(" "),_("li",[_("code",[v._v("AtomicInteger")]),v._v(": 使用CAS实现操作")]),v._v(" "),_("li",[_("code",[v._v("ABA")]),v._v(": CAS存在的问题, 一个变量被读取时是A, 经过多次修改又改回了A, 导致CAS认为其未发生变化, AtomicStampedReference解决(一般不影响线程安全)")])])]),v._v(" "),_("li",[v._v("无同步方案:\n"),_("ul",[_("li",[_("code",[v._v("栈封闭")]),v._v(": 线程自己的栈内变量无线程安全问题")]),v._v(" "),_("li",[_("code",[v._v("线程本地存储")]),v._v(": 将线程共享数据的代码在同一线程中执行, 如一个Web请求对应一个服务器线程")])])])]),v._v(" "),_("h2",{attrs:{id:"线程的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程的实现"}},[v._v("#")]),v._v(" 线程的实现")]),v._v(" "),_("ul",[_("li",[v._v("实现Runnable接口, 无返回值, 不能抛出异常")]),v._v(" "),_("li",[v._v("实现Callable接口, 有返回值, 可抛出异常")]),v._v(" "),_("li",[v._v("继承Thread类")])]),v._v(" "),_("h2",{attrs:{id:"线程基础使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程基础使用"}},[v._v("#")]),v._v(" 线程基础使用")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Thread::setDaemon()")]),v._v(": 设置守护线程, 守护线程为后台进程, 所有非守护进程结束时杀死守护线程")]),v._v(" "),_("li",[_("code",[v._v("Thread.yield()")]),v._v(": 声明线程已完成重要部分, 可让同优先级其他线程优先运行")]),v._v(" "),_("li",[_("code",[v._v("Thread::interrupt()")]),v._v(": 外部调用为中断进程, 内部调用(仅限于继承Thread用法)为判断进程是否中断")])]),v._v(" "),_("h3",{attrs:{id:"线程同步互斥"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程同步互斥"}},[v._v("#")]),v._v(" 线程同步互斥")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("synchronized")]),v._v(": 同步一个代码块/方法/类/静态方法, JVM实现, 不可等待中断, 非公平锁")]),v._v(" "),_("li",[_("code",[v._v("ReentrantLock")]),v._v(": JDK实现, 可等待中断, 公平锁/非公平锁")])]),v._v(" "),_("hr"),v._v(" "),_("ul",[_("li",[_("code",[v._v("wait(), notify(), notifyAll()")]),v._v(": Object自带")]),v._v(" "),_("li",[_("code",[v._v("await(), signal(), signalAll()")]),v._v(": JUC实现的Condition, 在"),_("code",[v._v("lock()")]),v._v("和"),_("code",[v._v("unlock()")]),v._v("之间使用")])]),v._v(" "),_("h2",{attrs:{id:"java锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java锁"}},[v._v("#")]),v._v(" Java锁")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("乐观锁")]),v._v(": 不锁住同步资源, 适合读操作多, 如CAS")]),v._v(" "),_("li",[_("code",[v._v("悲观锁")]),v._v(": 锁住同步资源, 适合写操作多, 如AtomicInteger")])]),v._v(" "),_("hr"),v._v(" "),_("ul",[_("li",[_("code",[v._v("自旋锁")]),v._v(": 获取同步资源失败时, 不放弃CPU时间片, 通过自旋尝试获取锁, 能减少CPU切换和恢复现场产生的损耗")]),v._v(" "),_("li",[_("code",[v._v("自适应自旋锁")]),v._v(": 根据之前自旋获取锁的成功情况调整自旋次数策略")])]),v._v(" "),_("hr"),v._v(" "),_("ul",[_("li",[_("code",[v._v("公平锁")]),v._v(": 线程按申请锁的顺序执行, 线程不会饿死, 但吞吐效率低")]),v._v(" "),_("li",[_("code",[v._v("非公平锁")]),v._v(": 线程直接尝试获取锁, 新线程获取锁无需唤醒旧线程, 减少唤醒线程开销, 吞吐率高, 但线程可能饿死, 如synchroinzed")])]),v._v(" "),_("hr"),v._v(" "),_("ul",[_("li",[_("code",[v._v("可重入锁")]),v._v(": 同一线程外层方法获取锁后进入内层方法, 内层方法自动获取锁(如锁同一个对象或class), 如ReentrantLock, synchronized")]),v._v(" "),_("li",[_("code",[v._v("非可重入锁")]),v._v(": 如NonReentrantLock")])]),v._v(" "),_("hr"),v._v(" "),_("ul",[_("li",[_("code",[v._v("独享锁/排他锁")]),v._v(": 锁一次只能被一个线程持有, 不能加上其他任何类型锁")]),v._v(" "),_("li",[_("code",[v._v("共享锁")]),v._v(": 可被多个线程持有, 只能读取数据不能修改")])]),v._v(" "),_("p",[_("strong",[v._v("JVM锁优化")]),v._v(":")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("锁消除")]),v._v(": 编译器将检测到不存在共享数据冲突的锁消除")]),v._v(" "),_("li",[_("code",[v._v("锁粗化")]),v._v(": 反复加锁的操作粗化到整个步骤加锁")]),v._v(" "),_("li",[_("code",[v._v("轻量级锁")]),v._v(": 用于大部分锁大部分时间处于无锁竞争状态的方案\n"),_("ol",[_("li",[v._v("在对象头"),_("code",[v._v("Object Header")]),v._v("中一部分存储对象自身的运行时数据"),_("code",[v._v("Mark Word")]),v._v("("),_("code",[v._v("HashCode")]),v._v(", "),_("code",[v._v("GC Age")]),v._v(", "),_("code",[v._v("锁标记位")]),v._v(", "),_("code",[v._v("是否为偏向锁")]),v._v("), 另一部分存储指向方法区对象类型数据的指针"),_("code",[v._v("Klass Word")])]),v._v(" "),_("li",[v._v("锁标记位状态包含: 00轻量级锁, 01无锁, 10重量级锁")]),v._v(" "),_("li",[v._v("若同步对象为01状态, 则执行当前线程时, 在当前线程栈帧中创建"),_("code",[v._v("Lock Record")]),v._v(", 存储同步对象的"),_("code",[v._v("Mark Word")]),v._v(", 并用CAS将同步对象的"),_("code",[v._v("Mark Word")]),v._v("修改为指向"),_("code",[v._v("Lock Record")]),v._v("的指针, 并将栈帧中存储"),_("code",[v._v("Mark Word")]),v._v("的状态改为00")]),v._v(" "),_("li",[v._v("如果CAS失败, 若"),_("code",[v._v("Mark Word")]),v._v("指向当前栈帧, 说明可以继续直接使用, 否则说明被其他线程抢占, 此时通过修改锁标记位为10将锁膨胀为重量级锁")])])]),v._v(" "),_("li",[_("code",[v._v("偏向锁")]),v._v(": 某一线程会更多的获取锁, 让该线程进出同步块无需CAS操作, 只需测试"),_("code",[v._v("Mark Word")]),v._v("是否存在该线程的偏向锁, 出现竞争时释放偏向锁并暂停偏向线程")])])])}),[],!1,null,null,null);_.default=o.exports}}]);