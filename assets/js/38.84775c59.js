(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{323:function(v,_,a){"use strict";a.r(_);var e=a(10),l=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gc"}},[v._v("#")]),v._v(" GC")]),v._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#判断可回收"}},[v._v("判断可回收")])]),_("li",[_("a",{attrs:{href:"#引用类型"}},[v._v("引用类型")])]),_("li",[_("a",{attrs:{href:"#垃圾回收算法"}},[v._v("垃圾回收算法")])]),_("li",[_("a",{attrs:{href:"#垃圾收集器"}},[v._v("垃圾收集器")])]),_("li",[_("a",{attrs:{href:"#内存分配与回收机制"}},[v._v("内存分配与回收机制")])])])]),_("p"),v._v(" "),_("h2",{attrs:{id:"判断可回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#判断可回收"}},[v._v("#")]),v._v(" 判断可回收")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("引用计数法")]),v._v(": 记录对对象的引用数, 当引用数为0时可被回收, 但循环引用会导致引用计数器不为0, java不使用该方法")]),v._v(" "),_("li",[_("code",[v._v("可达性分析")]),v._v(": 以"),_("code",[v._v("GC Roots")]),v._v("为起点搜索, 可达对象是存活的, 不可达对象被回收")])]),v._v(" "),_("h2",{attrs:{id:"引用类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[v._v("#")]),v._v(" 引用类型")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("强引用")]),v._v(": 不会被回收")]),v._v(" "),_("li",[_("code",[v._v("软引用")]),v._v(": 内存不够时回收")]),v._v(" "),_("li",[_("code",[v._v("弱引用")]),v._v(": gc发生时回收")]),v._v(" "),_("li",[_("code",[v._v("虚引用")]),v._v(": 用于在对象被回收时收到系统通知")])]),v._v(" "),_("h2",{attrs:{id:"垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[v._v("#")]),v._v(" 垃圾回收算法")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("标记-清除")]),v._v(": 标记存活, 清除未标记. 效率低, 存在内存碎片")]),v._v(" "),_("li",[_("code",[v._v("标记-整理")]),v._v(": 存活对象重排为连续紧密的内存空间, 清除边界外内存空间")]),v._v(" "),_("li",[_("code",[v._v("复制")]),v._v(": 内存分为两部分, 每次使用一部分, gc时将使用部分的存活对象复制到另一部分的连续内存中")]),v._v(" "),_("li",[_("code",[v._v("分代")]),v._v(": 根据对象存活周期分代, 新生代通常用"),_("code",[v._v("复制")]),v._v(", 老年代通常用"),_("code",[v._v("标记-清除")]),v._v("或"),_("code",[v._v("标记-整理")])])]),v._v(" "),_("h2",{attrs:{id:"垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[v._v("#")]),v._v(" 垃圾收集器")]),v._v(" "),_("p",[_("strong",[v._v("串行")]),v._v(": 指垃圾回收和用户程序交替进行, 与"),_("strong",[v._v("并行")]),v._v("相对")]),v._v(" "),_("p",[v._v("下图为HotSpot中主要的垃圾收集器, 连线表示可以配合使用")]),v._v(" "),_("img",{attrs:{src:v.$withBase("/java/gc.jpg"),alt:"gc"}}),v._v(" "),_("ul",[_("li",[_("code",[v._v("Serial")]),v._v(": 串行, 单线程, 新生代复制")]),v._v(" "),_("li",[_("code",[v._v("ParNew")]),v._v(": 串行, 多线程, 新生代复制")]),v._v(" "),_("li",[_("code",[v._v("Parallel Scavenge")]),v._v(": "),_("code",[v._v("ParNew")]),v._v("的吞吐量优先版(指用户代码占CPU总时更大), 其他收集器一般垃圾回收频繁, 但停顿时间短")]),v._v(" "),_("li",[_("code",[v._v("Serial Old")]),v._v(": "),_("code",[v._v("Serial")]),v._v("老年代版, 标记-整理")]),v._v(" "),_("li",[_("code",[v._v("Parallel Old")]),v._v(": "),_("code",[v._v("Parallel Scavenge")]),v._v("老年代版, 标记-整理")]),v._v(" "),_("li",[_("code",[v._v("CMS")]),v._v(": 老年代收集器, 使用标记清除\n"),_("ol",[_("li",[v._v("初始标记: 标记"),_("code",[v._v("GC Roots")]),v._v("能直接关联的对象, 停顿, 快速")]),v._v(" "),_("li",[v._v("并发标记: 标记通过"),_("code",[v._v("GC Roots")]),v._v("能达到的所有对象, 不停顿, 耗时最长")]),v._v(" "),_("li",[v._v("重新标记: 修正上一步进行时产生变动的对象的记录, 停顿")]),v._v(" "),_("li",[v._v("并发清除: 不停顿, 耗时长")])]),v._v(" "),_("ul",[_("li",[v._v("缺点: 吞吐量低, 并发清除清除阶段有浮动垃圾只能下一次GC处理, 收集后存在空间碎片, 容易导致提前"),_("code",[v._v("Full GC")])])])]),v._v(" "),_("li",[_("code",[v._v("G1")]),v._v(": 对新生代和老年代均回收, 用Region的概念将内存空间划分为多个小空间,每个小空间单独GC, 使得停顿时间可预测\n"),_("ol",[_("li",[v._v("初始标记")]),v._v(" "),_("li",[v._v("并发标记")]),v._v(" "),_("li",[v._v("最终标记: 修正并发标记中产生变动的对象, 停顿")]),v._v(" "),_("li",[v._v("筛选回收: 对Region排序, 根据用户期望GC停顿时间指定回收计划")])])])]),v._v(" "),_("h2",{attrs:{id:"内存分配与回收机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存分配与回收机制"}},[v._v("#")]),v._v(" 内存分配与回收机制")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Minor GC/Young GC")]),v._v(": 仅对新生代的GC")]),v._v(" "),_("li",[_("code",[v._v("Major GC/Old GC")]),v._v(": 仅对老年代的GC, 目前仅"),_("code",[v._v("CMS")])]),v._v(" "),_("li",[_("code",[v._v("Mixed GC")]),v._v(": 收集整个新生代和部分老年代, 目前仅"),_("code",[v._v("G1")])]),v._v(" "),_("li",[_("code",[v._v("Full GC")]),v._v(": 收集整个java堆和方法区")])])])}),[],!1,null,null,null);_.default=l.exports}}]);