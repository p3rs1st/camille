(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{321:function(e,a,v){"use strict";v.r(a);var t=v(10),_=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"集合框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合框架"}},[e._v("#")]),e._v(" 集合框架")]),e._v(" "),a("blockquote",[a("p",[e._v("容器包含Collection(存储对象的集合)和Map(存储键值对映射表)")])]),e._v(" "),a("h2",{attrs:{id:"collection两组语义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#collection两组语义"}},[e._v("#")]),e._v(" Collection两组语义")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th",[e._v("抛出异常")]),e._v(" "),a("th",[e._v("返回特定值(如null)")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("插入")]),e._v(" "),a("td",[e._v("add")]),e._v(" "),a("td",[e._v("offer")])]),e._v(" "),a("tr",[a("td",[e._v("删除")]),e._v(" "),a("td",[e._v("remove")]),e._v(" "),a("td",[e._v("poll")])]),e._v(" "),a("tr",[a("td",[e._v("获取")]),e._v(" "),a("td",[e._v("element")]),e._v(" "),a("td",[e._v("peek")])])])]),e._v(" "),a("h2",{attrs:{id:"set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" Set")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("TreeSet")]),e._v(": 红黑树实现, 支持有序操作, 效率低于HashSet, 查找复杂度O(log n)")]),e._v(" "),a("li",[a("code",[e._v("HashSet")]),e._v(": 哈希表实现, 不支持有序操作, 查找复杂度O(1), 哈希冲突少时用链表, 多时用红黑树")]),e._v(" "),a("li",[a("code",[e._v("LinkedHashSet")]),e._v(": HashSet基础上用双向链表维护元素插入顺序")])]),e._v(" "),a("h2",{attrs:{id:"list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[e._v("#")]),e._v(" List")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("ArrayList")]),e._v(": 动态数组, 随机访问, 允许null元素")]),e._v(" "),a("li",[a("code",[e._v("Vector")]),e._v(": 线程安全的ArrayList")]),e._v(" "),a("li",[a("code",[e._v("LinkedList")]),e._v(": 双向链表, 顺序访问, 允许null元素")])]),e._v(" "),a("h3",{attrs:{id:"arraylist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[e._v("#")]),e._v(" ArrayList")]),e._v(" "),a("ul",[a("li",[e._v("初始容量默认10")]),e._v(" "),a("li",[e._v("每次扩容为1.5倍")]),e._v(" "),a("li",[e._v("底层为数组")]),e._v(" "),a("li",[e._v("使用modCount记录修改次数, 使得并发时迭代器使用会抛出异常")])]),e._v(" "),a("h3",{attrs:{id:"copyonwritearraylist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist"}},[e._v("#")]),e._v(" CopyOnWriteArrayList")]),e._v(" "),a("ul",[a("li",[e._v("并发安全, 适合读多写少")]),e._v(" "),a("li",[e._v("读操作直接读取数组")]),e._v(" "),a("li",[e._v("写操作加锁, 复制数组, 修改, 写回原数组")]),e._v(" "),a("li",[e._v("写操作之间互斥, 读操作发生在写操作释放锁之前均读取到旧数据")]),e._v(" "),a("li",[e._v("缺点: 实时读取不能保证数据正确, 数组较大时, 每次修改均复制数组")])]),e._v(" "),a("h3",{attrs:{id:"vector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vector"}},[e._v("#")]),e._v(" Vector")]),e._v(" "),a("ul",[a("li",[e._v("并发安全, 效率低于CopyOnWriteArrayList")]),e._v(" "),a("li",[e._v("所有操作对整个对象加锁")])]),e._v(" "),a("h2",{attrs:{id:"queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[e._v("#")]),e._v(" Queue")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("LinkedList")]),e._v(": 链表的双向队列")]),e._v(" "),a("li",[a("code",[e._v("PriorityQueue")]),e._v(": 堆实现, 优先队列")]),e._v(" "),a("li",[a("code",[e._v("ArrayDeque")]),e._v(": 数组的循环队列, 不允许null元素")])]),e._v(" "),a("h3",{attrs:{id:"arraydeque"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraydeque"}},[e._v("#")]),e._v(" ArrayDeque")]),e._v(" "),a("ul",[a("li",[e._v("循环队列, 队列满时double容量")]),e._v(" "),a("li",[e._v("double扩容时, 重新按head到tail的顺序编排")])]),e._v(" "),a("h3",{attrs:{id:"concurrentlinkedqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrentlinkedqueue"}},[e._v("#")]),e._v(" ConcurrentLinkedQueue")]),e._v(" "),a("ul",[a("li",[e._v("无锁实现并发安全")]),e._v(" "),a("li",[e._v("采用HOPS(延迟更新)策略, tail的next不为null时才会重新定位tail, head的item为null时才会重新定位head")]),e._v(" "),a("li",[e._v("存在节点next指向自己, 为哨兵节点或出队节点")])]),e._v(" "),a("h2",{attrs:{id:"blockingqueue-blockingdeque"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blockingqueue-blockingdeque"}},[e._v("#")]),e._v(" BlockingQueue & BlockingDeque")]),e._v(" "),a("ul",[a("li",[e._v("接口")]),e._v(" "),a("li",[e._v("在Queue的基础上添加了阻塞操作"),a("code",[e._v("put(o)")]),e._v("和"),a("code",[e._v("take()")]),e._v(", 超时操作"),a("code",[e._v("offer(o, timeout, timeunit)")]),e._v("和"),a("code",[e._v("poll(timeout, timeunit)")])]),e._v(" "),a("li",[e._v("阻塞操作表示如果操作无法立即执行会阻塞线程(队列长度达到容量上线时会阻塞, 没有元素尝试获取时会阻塞)")]),e._v(" "),a("li",[e._v("超时操作表示阻塞操作的限时版")]),e._v(" "),a("li",[e._v("BlockingDeque为基于Deque的类似版")]),e._v(" "),a("li",[e._v("具体实现有"),a("code",[e._v("Array*")]),e._v("和"),a("code",[e._v("Linked*")])])]),e._v(" "),a("h3",{attrs:{id:"delayqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delayqueue"}},[e._v("#")]),e._v(" DelayQueue")]),e._v(" "),a("ul",[a("li",[e._v("实现BlockingQueue的线程安全的队列")]),e._v(" "),a("li",[e._v("元素为Delayed的继承类型, 队列根据过期时间做优先队列")]),e._v(" "),a("li",[e._v("取元素只能取出最先过期且已过期的元素")])]),e._v(" "),a("h3",{attrs:{id:"synchronousqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronousqueue"}},[e._v("#")]),e._v(" SynchronousQueue")]),e._v(" "),a("ul",[a("li",[e._v("实现BlockingQueue且只能容纳一个元素")])]),e._v(" "),a("h2",{attrs:{id:"map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" Map")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("TreeMap")]),e._v(": 红黑树实现")]),e._v(" "),a("li",[a("code",[e._v("HashMap")]),e._v(": 哈希表实现, 允许key, value为null")]),e._v(" "),a("li",[a("code",[e._v("HashTable")]),e._v(": 线程安全的HashTable, 但已被抛弃")]),e._v(" "),a("li",[a("code",[e._v("LinkedHashMap")]),e._v(": 双向链表维护元素顺序, 顺序为插入顺序或最少使用顺序")]),e._v(" "),a("li",[a("code",[e._v("WeakHashMap")]),e._v(": 元素可能被GC自动删除, 适用于缓存场景")])]),e._v(" "),a("h3",{attrs:{id:"hashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[e._v("#")]),e._v(" HashMap")]),e._v(" "),a("ul",[a("li",[e._v("HashSet内的实现为使用HashMap")]),e._v(" "),a("li",[e._v("HashMap元素需实现"),a("code",[e._v("hashCode()")]),e._v("和"),a("code",[e._v("equals()")])]),e._v(" "),a("li",[e._v("哈希表大小为2的幂方, 当元素数大于阈值(容量 * 加载因子)时扩容, java8扩容时优化扩容过程, 基于扩容时哈希结果只有最高位不同")]),e._v(" "),a("li",[e._v("java7用冲突链表, java8当冲突链表长度到达8时转为红黑树")])]),e._v(" "),a("h3",{attrs:{id:"treemap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[e._v("#")]),e._v(" TreeMap")]),e._v(" "),a("ul",[a("li",[e._v("红黑树")]),e._v(" "),a("li",[e._v("每个节点为红色或黑色, 根节点为黑色")]),e._v(" "),a("li",[e._v("红色节点不能连续")]),e._v(" "),a("li",[e._v("每个节点到所有叶子节点路径有相同黑色节点数量")])]),e._v(" "),a("h3",{attrs:{id:"hashtable-concurrenthashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashtable-concurrenthashmap"}},[e._v("#")]),e._v(" Hashtable & ConcurrentHashMap")]),e._v(" "),a("ul",[a("li",[e._v("解决线程安全问题的HashMap")]),e._v(" "),a("li",[e._v("Hashtable对所有操作加锁, 且锁是对整个对象加锁, 效率低, 并且快速失败")]),e._v(" "),a("li",[e._v("jdk7的ConcurrentHashMap使用的是纯冲突链表, 使用固定的分段数加分段锁(ReentrantLock)分段同步, 哈希扩容对每个分段进行扩容, 且只对写操作加锁")]),e._v(" "),a("li",[e._v("jdk8的ConcurrentHashMap使用了冲突链表加红黑树, 对同一个哈希值的数据结构使用synchronized加锁(源于jdk8对synchronized的优化), 支持多线程扩容, 只对写操作加锁")])])])}),[],!1,null,null,null);a.default=_.exports}}]);