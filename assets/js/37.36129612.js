(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{322:function(v,_,a){"use strict";a.r(_);var t=a(10),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"理论基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#理论基础"}},[v._v("#")]),v._v(" 理论基础")]),v._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#jvm整体架构"}},[v._v("JVM整体架构")])]),_("li",[_("a",{attrs:{href:"#类字节码"}},[v._v("类字节码")])]),_("li",[_("a",{attrs:{href:"#jmm-java-memory-model"}},[v._v("JMM(Java Memory Model)")]),_("ul",[_("li",[_("a",{attrs:{href:"#程序计数器"}},[v._v("程序计数器")])]),_("li",[_("a",{attrs:{href:"#虚拟机栈"}},[v._v("虚拟机栈")])]),_("li",[_("a",{attrs:{href:"#本地方法栈"}},[v._v("本地方法栈")])]),_("li",[_("a",{attrs:{href:"#堆"}},[v._v("堆")])]),_("li",[_("a",{attrs:{href:"#方法区"}},[v._v("方法区")])])])]),_("li",[_("a",{attrs:{href:"#类加载机制"}},[v._v("类加载机制")]),_("ul",[_("li",[_("a",{attrs:{href:"#类加载过程"}},[v._v("类加载过程")])]),_("li",[_("a",{attrs:{href:"#类加载器"}},[v._v("类加载器")])]),_("li",[_("a",{attrs:{href:"#jvm类加载机制"}},[v._v("JVM类加载机制")])])])])])]),_("p"),v._v(" "),_("h2",{attrs:{id:"jvm整体架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm整体架构"}},[v._v("#")]),v._v(" JVM整体架构")]),v._v(" "),_("img",{attrs:{src:v.$withBase("/java/JVM.png"),alt:"JVM"}}),v._v(" "),_("h2",{attrs:{id:"类字节码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类字节码"}},[v._v("#")]),v._v(" 类字节码")]),v._v(" "),_("p",[v._v("class文件是以8字节为单位的二进制流, java文件编译为class文件后, 可以被jvm识别以及运行")]),v._v(" "),_("p",[_("strong",[v._v("文件结构")]),v._v(":")]),v._v(" "),_("img",{attrs:{src:v.$withBase("/java/java-jvm-class-2.png"),alt:"java-jvm-class-2"}}),v._v(" "),_("h2",{attrs:{id:"jmm-java-memory-model"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jmm-java-memory-model"}},[v._v("#")]),v._v(" JMM(Java Memory Model)")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("线程私有")]),v._v(": 程序计数器, 虚拟机栈, 本地方法区")]),v._v(" "),_("li",[_("code",[v._v("线程共享")]),v._v(": 堆, 方法区, 堆外内存(java7永久代, java8元空间)")])]),v._v(" "),_("h3",{attrs:{id:"程序计数器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[v._v("#")]),v._v(" 程序计数器")]),v._v(" "),_("blockquote",[_("p",[v._v("线程私有的, 记录线程运行到的字节码指令地址")])]),v._v(" "),_("h3",{attrs:{id:"虚拟机栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[v._v("#")]),v._v(" 虚拟机栈")]),v._v(" "),_("blockquote",[_("p",[v._v("保存方法的局部变量, 部分结果, 方法的调用和返回")])]),v._v(" "),_("ul",[_("li",[v._v("大小是动态或固定不变的\n"),_("ul",[_("li",[_("code",[v._v("固定不变")]),v._v(": 在有线程请求分配栈容量超过最大容量时, 抛出"),_("code",[v._v("StackOverflowError")])]),v._v(" "),_("li",[_("code",[v._v("动态")]),v._v(": 尝试扩展时无法申请足够内存, 或新线程无法申请足够内存, 抛出"),_("code",[v._v("OutOfMemoryError")])])])]),v._v(" "),_("li",[_("code",[v._v("-Xss")]),v._v("设置栈空间大小")]),v._v(" "),_("li",[v._v("每个线程有自己的栈, 以栈帧格式存在, 正在运行的方法对应一个栈帧, 栈帧包含以下数据\n"),_("ul",[_("li",[_("code",[v._v("局部变量表")]),v._v(": 在编译器确定大小")]),v._v(" "),_("li",[_("code",[v._v("操作数栈")]),v._v(": 保存计算的中间结果")]),v._v(" "),_("li",[_("code",[v._v("动态链接")]),v._v(": 将符号引用转为调用方法的直接引用")]),v._v(" "),_("li",[_("code",[v._v("方法返回地址")]),v._v(": 存放调用该方法的PC值")])])])]),v._v(" "),_("h3",{attrs:{id:"本地方法栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),_("ul",[_("li",[v._v("与其他语言交互")]),v._v(" "),_("li",[v._v("与操作系统交互")]),v._v(" "),_("li",[v._v("在HotSpot中本地方法栈和虚拟机栈合二为一")])]),v._v(" "),_("h3",{attrs:{id:"堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),_("ul",[_("li",[v._v("存放对象实例, 逻辑上分为三代(分代理由为优化gc性能), 新生代, 老年代, 元空间\n"),_("ul",[_("li",[_("code",[v._v("新生代")]),v._v(": 新对象, 使用次数较少, 使用"),_("code",[v._v("Minor GC")]),v._v(", 分为"),_("code",[v._v("Eden:From Survivor:To Survivor=8:1:1")]),v._v(".\n"),_("ol",[_("li",[v._v("新对象在"),_("code",[v._v("Eden")]),v._v("创建")]),v._v(" "),_("li",[_("code",[v._v("Minor GC")]),v._v("时将"),_("code",[v._v("Eden")]),v._v("和"),_("code",[v._v("From Survivor")]),v._v("中存活对象复制到"),_("code",[v._v("To Survivor")])]),v._v(" "),_("li",[v._v("清空"),_("code",[v._v("Eden")]),v._v("和"),_("code",[v._v("From Survivor")])]),v._v(" "),_("li",[v._v("交换"),_("code",[v._v("From Survivor")]),v._v("和"),_("code",[v._v("To Survivor")])]),v._v(" "),_("li",[v._v("存活一定次数后的对象移动到老年代")])])]),v._v(" "),_("li",[_("code",[v._v("老年代")]),v._v(": 使用次数较多的对象或大对象, 使用"),_("code",[v._v("Major GC")])])])]),v._v(" "),_("li",[_("code",[v._v("-Xmx")]),v._v("设置最大堆内存(默认"),_("code",[v._v("电脑内存/4")]),v._v(")和"),_("code",[v._v("-Xms")]),v._v("设置堆起始内存(默认"),_("code",[v._v("电脑内存/64")]),v._v("), 堆大小超过"),_("code",[v._v("-Xmx")]),v._v("抛出"),_("code",[v._v("OutOfMemoryError")])]),v._v(" "),_("li",[_("code",[v._v("Mixed GC")]),v._v(": 整个新生代和部分老年代的"),_("code",[v._v("GC")]),v._v(", "),_("code",[v._v("Full GC")]),v._v(": 整个java堆和方法区的"),_("code",[v._v("GC")])]),v._v(" "),_("li",[_("code",[v._v("TLAB")]),v._v("(Thread Local Allocation Buffer): 对"),_("code",[v._v("Eden")]),v._v("划分, 每个线程有一个私有缓存区, 避免部分线程安全问题")])]),v._v(" "),_("h4",{attrs:{id:"逃逸分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#逃逸分析"}},[v._v("#")]),v._v(" 逃逸分析")]),v._v(" "),_("blockquote",[_("p",[v._v("分析一个对象的引用的使用范围从而决定是否将对象分配到堆上")]),v._v(" "),_("p",[v._v("方法中定义且只在方法中使用不会逃逸, 方法中定义但被外部方法引用(如作为返回值)则会逃逸")])]),v._v(" "),_("ol",[_("li",[_("code",[v._v("同步省略")]),v._v(": 非逃逸对象只能被一个线程访问, 则取消同步代码")]),v._v(" "),_("li",[_("code",[v._v("标量替换")]),v._v(": 非逃逸对象无需连续内存, 可以仅保存对象的部分字段, 存储在CPU寄存器中")]),v._v(" "),_("li",[_("code",[v._v("栈上分配")]),v._v(": 非逃逸对象由堆分配转为栈分配")])]),v._v(" "),_("h3",{attrs:{id:"方法区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),_("blockquote",[_("p",[v._v("存储类信息、常量池、静态变量、JIT编译后的代码等数据")])]),v._v(" "),_("ul",[_("li",[v._v("永久代和元空间是方法区的具体实现, 永久代是堆的一部分, 元空间存在本地内存(堆外内存)")]),v._v(" "),_("li",[v._v("移除永久代原因(仅HotSpot中有): 永久代设置空间大小难确定, 永久代调优困难")]),v._v(" "),_("li",[v._v("垃圾回收: 常量池中废弃的常量和不再使用的类型")])]),v._v(" "),_("h2",{attrs:{id:"类加载机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载机制"}},[v._v("#")]),v._v(" 类加载机制")]),v._v(" "),_("h3",{attrs:{id:"类加载过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[v._v("#")]),v._v(" 类加载过程")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("加载")]),v._v(": 通过类的全限定名获取二进制字节流, 将其中表示的静态结构转为方法区的运行时数据结构, 在堆中生成一个代表该类的java.lang.Class对象作为对方法区这些数据的访问入口")]),v._v(" "),_("li",[_("code",[v._v("验证")]),v._v(": 确保被加载的类的正确性, 包括文件格式验证, 元数据验证, 字节码验证, 符号引用验证")]),v._v(" "),_("li",[_("code",[v._v("准备")]),v._v(": 在方法区为静态变量分配内存并初始化为默认值")]),v._v(" "),_("li",[_("code",[v._v("解析")]),v._v(": 将符号引用转为直接引用")]),v._v(" "),_("li",[_("code",[v._v("初始化")]),v._v(": 变量初始值以及静态代码块")])]),v._v(" "),_("h3",{attrs:{id:"类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[v._v("#")]),v._v(" 类加载器")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("启动类加载器")]),v._v(": JVM自身需要的类, 由C++实现")]),v._v(" "),_("li",[_("code",[v._v("扩展类加载器")]),v._v(": Sun公司用Java实现的类, 开发者可用")]),v._v(" "),_("li",[_("code",[v._v("应用程序类加载器")]),v._v(": 加载用户类路径所指定的类, 未自定义自己的类加载器的应用程序使用的类加载器")]),v._v(" "),_("li",[_("code",[v._v("自定义类加载器")]),v._v(": 用户编写的类加载器")])]),v._v(" "),_("h4",{attrs:{id:"类加载实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载实现"}},[v._v("#")]),v._v(" 类加载实现")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Class.forName()")]),v._v(": 将class文件加载到JVM, 并解释类, 执行static块, 带参数的版本可控制是否执行static块")]),v._v(" "),_("li",[_("code",[v._v("ClassLoader.loadClass()")]),v._v(": 仅将class文件加载到JVM, 不执行static块")])]),v._v(" "),_("h3",{attrs:{id:"jvm类加载机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm类加载机制"}},[v._v("#")]),v._v(" JVM类加载机制")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("全盘负责")]),v._v(": 加载某个Class时其所有依赖Class均由该类加载器加载")]),v._v(" "),_("li",[_("code",[v._v("父类委托")]),v._v(": 让父类加载器尝试加载, 无法加载时从自己的类路径加载")]),v._v(" "),_("li",[_("code",[v._v("缓存机制")]),v._v(": 加载过的Class被缓存, 不存在缓存区的Class才会加载并转化为Class对象存入缓存区")]),v._v(" "),_("li",[_("code",[v._v("双亲委派机制")]),v._v(": 收到类加载请求时先委托父类加载器, 然后继续委托父类的父类加载器, 直到顶层, 当父类加载器无法加载才会让子类加载器加载\n"),_("ul",[_("li",[v._v("优势: 防止内存出现相同的字节码, 保证java程序安全稳定运行")])])])])])}),[],!1,null,null,null);_.default=r.exports}}]);