<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>java库 | Never See</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="不见">
    
    <link rel="preload" href="/camille/assets/css/0.styles.ac02bd7f.css" as="style"><link rel="preload" href="/camille/assets/js/app.89cf657d.js" as="script"><link rel="preload" href="/camille/assets/js/2.c0d8e570.js" as="script"><link rel="preload" href="/camille/assets/js/1.b1971c90.js" as="script"><link rel="preload" href="/camille/assets/js/40.665ccab0.js" as="script"><link rel="prefetch" href="/camille/assets/js/10.655a1089.js"><link rel="prefetch" href="/camille/assets/js/11.e879aba2.js"><link rel="prefetch" href="/camille/assets/js/12.3d71d70f.js"><link rel="prefetch" href="/camille/assets/js/13.b40e96b9.js"><link rel="prefetch" href="/camille/assets/js/14.a15c23f8.js"><link rel="prefetch" href="/camille/assets/js/15.086621a3.js"><link rel="prefetch" href="/camille/assets/js/16.38ad00d8.js"><link rel="prefetch" href="/camille/assets/js/17.7d9f6541.js"><link rel="prefetch" href="/camille/assets/js/18.58f20acb.js"><link rel="prefetch" href="/camille/assets/js/19.cf2cf075.js"><link rel="prefetch" href="/camille/assets/js/20.f36b6fbb.js"><link rel="prefetch" href="/camille/assets/js/21.d1e109e6.js"><link rel="prefetch" href="/camille/assets/js/22.e5e7d61e.js"><link rel="prefetch" href="/camille/assets/js/23.c0b72d40.js"><link rel="prefetch" href="/camille/assets/js/24.24755f5b.js"><link rel="prefetch" href="/camille/assets/js/25.e79f3b27.js"><link rel="prefetch" href="/camille/assets/js/26.a28b8735.js"><link rel="prefetch" href="/camille/assets/js/27.2019210c.js"><link rel="prefetch" href="/camille/assets/js/28.195e9507.js"><link rel="prefetch" href="/camille/assets/js/29.da9a1b36.js"><link rel="prefetch" href="/camille/assets/js/3.c9a6670a.js"><link rel="prefetch" href="/camille/assets/js/30.7e78e35a.js"><link rel="prefetch" href="/camille/assets/js/31.742a34b1.js"><link rel="prefetch" href="/camille/assets/js/32.c69a703e.js"><link rel="prefetch" href="/camille/assets/js/33.9a798fe0.js"><link rel="prefetch" href="/camille/assets/js/34.09ed62b4.js"><link rel="prefetch" href="/camille/assets/js/35.40c45f3a.js"><link rel="prefetch" href="/camille/assets/js/36.30460db4.js"><link rel="prefetch" href="/camille/assets/js/37.36129612.js"><link rel="prefetch" href="/camille/assets/js/38.84775c59.js"><link rel="prefetch" href="/camille/assets/js/39.233eb667.js"><link rel="prefetch" href="/camille/assets/js/4.51108671.js"><link rel="prefetch" href="/camille/assets/js/41.8f5e492c.js"><link rel="prefetch" href="/camille/assets/js/42.bc9f0e34.js"><link rel="prefetch" href="/camille/assets/js/43.203e2859.js"><link rel="prefetch" href="/camille/assets/js/44.d6e345f5.js"><link rel="prefetch" href="/camille/assets/js/5.c5132282.js"><link rel="prefetch" href="/camille/assets/js/6.89d8cb10.js"><link rel="prefetch" href="/camille/assets/js/7.ee093510.js"><link rel="prefetch" href="/camille/assets/js/vendors~docsearch.3d49b2ab.js">
    <link rel="stylesheet" href="/camille/assets/css/0.styles.ac02bd7f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/camille/" class="home-link router-link-active"><!----> <span class="site-name">Never See</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/camille/tool/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/camille/always/network.html" class="nav-link">
  常用表
</a></div><div class="nav-item"><a href="/camille/basic/network.html" class="nav-link">
  基础知识
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/camille/database/mysql.html" class="nav-link">
  MySQL
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论知识
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/camille/java/theory/basic/basic.html" class="nav-link">
  基础理论
</a></li><li class="dropdown-subitem"><a href="/camille/java/theory/multi_process/basic.html" class="nav-link">
  多进程
</a></li><li class="dropdown-subitem"><a href="/camille/java/theory/jvm/basic.html" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          SpringBoot
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/camille/java/springboot/bug.html" class="nav-link">
  bugs
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架" class="mobile-dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/camille/framework/springcloud/" class="nav-link">
  SpringCloud
</a></li><li class="dropdown-item"><!----> <a href="/camille/framework/dubbo/" class="nav-link">
  Dubbo
</a></li></ul></div></div><div class="nav-item"><a href="/camille/unorganized/" class="nav-link">
  待整理
</a></div><div class="nav-item"><a href="/camille/life/" class="nav-link">
  生活
</a></div><div class="nav-item"><a href="/camille/system/" class="nav-link">
  系统安装
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/camille/tool/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/camille/always/network.html" class="nav-link">
  常用表
</a></div><div class="nav-item"><a href="/camille/basic/network.html" class="nav-link">
  基础知识
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/camille/database/mysql.html" class="nav-link">
  MySQL
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论知识
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/camille/java/theory/basic/basic.html" class="nav-link">
  基础理论
</a></li><li class="dropdown-subitem"><a href="/camille/java/theory/multi_process/basic.html" class="nav-link">
  多进程
</a></li><li class="dropdown-subitem"><a href="/camille/java/theory/jvm/basic.html" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          SpringBoot
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/camille/java/springboot/bug.html" class="nav-link">
  bugs
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架" class="mobile-dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/camille/framework/springcloud/" class="nav-link">
  SpringCloud
</a></li><li class="dropdown-item"><!----> <a href="/camille/framework/dubbo/" class="nav-link">
  Dubbo
</a></li></ul></div></div><div class="nav-item"><a href="/camille/unorganized/" class="nav-link">
  待整理
</a></div><div class="nav-item"><a href="/camille/life/" class="nav-link">
  生活
</a></div><div class="nav-item"><a href="/camille/system/" class="nav-link">
  系统安装
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>基础理论</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/camille/java/theory/basic/basic.html" class="sidebar-link">基础</a></li><li><a href="/camille/java/theory/basic/mechanism.html" class="sidebar-link">机制</a></li><li><a href="/camille/java/theory/basic/collection.html" class="sidebar-link">集合框架</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>多线程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/camille/java/theory/multi_process/basic.html" class="sidebar-link">理论基础</a></li><li><a href="/camille/java/theory/multi_process/javalib.html" aria-current="page" class="active sidebar-link">java库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/camille/java/theory/multi_process/javalib.html#关键字" class="sidebar-link">关键字</a></li><li class="sidebar-sub-header"><a href="/camille/java/theory/multi_process/javalib.html#基本类" class="sidebar-link">基本类</a></li><li class="sidebar-sub-header"><a href="/camille/java/theory/multi_process/javalib.html#基本接口" class="sidebar-link">基本接口</a></li><li class="sidebar-sub-header"><a href="/camille/java/theory/multi_process/javalib.html#源码细读" class="sidebar-link">源码细读</a></li><li class="sidebar-sub-header"><a href="/camille/java/theory/multi_process/javalib.html#线程池" class="sidebar-link">线程池</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/camille/java/theory/jvm/basic.html" class="sidebar-link">理论基础</a></li><li><a href="/camille/java/theory/jvm/gc.html" class="sidebar-link">GC</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java库"><a href="#java库" class="header-anchor">#</a> java库</h1> <p></p><div class="table-of-contents"><ul><li><a href="#关键字">关键字</a><ul><li><a href="#synchronized">synchronized</a></li><li><a href="#volatile">volatile</a></li><li><a href="#final">final</a></li></ul></li><li><a href="#基本类">基本类</a><ul><li><a href="#unsafe">Unsafe</a></li><li><a href="#原子类">原子类</a></li><li><a href="#locksuppport">LockSuppport</a></li><li><a href="#threadlocal">ThreadLocal</a></li></ul></li><li><a href="#基本接口">基本接口</a><ul><li><a href="#condition">Condition</a></li><li><a href="#lock">Lock</a></li></ul></li><li><a href="#源码细读">源码细读</a><ul><li><a href="#锁核心类aqs-abstractqueuedsynchronizer">锁核心类AQS(AbstractQueuedSynchronizer)</a></li><li><a href="#reentrantlock">ReentrantLock</a></li><li><a href="#reentrantreadwritelock">ReentrantReadWriteLock</a></li></ul></li><li><a href="#线程池">线程池</a><ul><li><a href="#线程池作用">线程池作用</a></li><li><a href="#future接口">Future接口</a></li><li><a href="#futuretask">FutureTask</a></li><li><a href="#threadpoolexecutor">ThreadPoolExecutor</a></li><li><a href="#forkjoinpool">ForkJoinPool</a></li><li><a href="#countdownlatch">CountDownLatch</a></li><li><a href="#cyclicbarrier">CyclicBarrier</a></li><li><a href="#semaphore">Semaphore</a></li><li><a href="#phaser">Phaser</a></li><li><a href="#exchanger">Exchanger</a></li></ul></li></ul></div><p></p> <h2 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h2> <h3 id="synchronized"><a href="#synchronized" class="header-anchor">#</a> synchronized</h3> <ul><li>指定锁定对象: this, 某一对象, .class</li> <li>修饰方法: 普通方法等价于this, 静态方法等价于.class</li> <li>加锁原理: 用monitor计数器表示被执行线程重入次数, 当monitor为0表示未锁, 大于0表示被重入次数</li> <li>缺点: 效率低, 不灵活, 无法得知是否成功获取锁</li></ul> <h3 id="volatile"><a href="#volatile" class="header-anchor">#</a> volatile</h3> <ul><li>作用: 防止重排(有序性), 共享变量修改可见(可见性)</li> <li>可见性实现: 使用lock前缀的指令, 使得线程缓存数据会写回主存, 且写回后其他线程缓存的该地址数据失效(缓存一致性协议, 嗅探协议)</li> <li>有序性实现: happens-before原则, 编译volatile变量的指令时, JMM提供内存屏障防止特定类型的重排方式</li></ul> <h3 id="final"><a href="#final" class="header-anchor">#</a> final</h3> <ul><li>final修饰的方法不可被重写, private方法默认为final</li> <li>final修饰的变量运算时不会自动转换类型</li> <li>static final: 必须在声明时赋值</li> <li>blank final: 声明为final的参数可在构造器中赋值</li> <li>重排规则: 禁止final域写重排到构造方法外, 禁止先读对象的final域再读对象的引用, 禁止先将final对象的引用赋值给引用变量再写入该对象</li></ul> <h2 id="基本类"><a href="#基本类" class="header-anchor">#</a> 基本类</h2> <h3 id="unsafe"><a href="#unsafe" class="header-anchor">#</a> Unsafe</h3> <ul><li>作用: 访问管理底层资源</li></ul> <img src="/camille/java/java-thread-x-atomicinteger-unsafe.png" alt="java-thread-x-atomicinteger-unsafe"> <h3 id="原子类"><a href="#原子类" class="header-anchor">#</a> 原子类</h3> <ul><li><code>AtomicInteger, AtomicBoolean, AtomicLong, ...</code>: 用volatile的变量以及Unsafe类的CAS修改数据</li> <li><code>AtomicReference</code>: 原子更新引用类型, 即用于自定义类的原子操作, 但仅对类中volatile修饰的字段有用</li> <li><code>AtomicStampedReference</code>: AtomicReference基础上使用Pair存储元素和版本号, 解决ABA问题</li> <li><code>AtomicMarkableReference</code>: 维护boolean标记, 解决ABA问题</li> <li><code>AtomicIntegerFieldUpdater</code>(Boolean, Stamped, Reference): 利用反射的方法, 指定类中的字段, 进行原子的更新操作, 该类可以对同类下不同的实例操作, 但非updater的只能对一个实例操作</li></ul> <h3 id="locksuppport"><a href="#locksuppport" class="header-anchor">#</a> LockSuppport</h3> <p>用于创建锁和其他同步类的基本线程阻塞原语, 直接使用LockSupport的静态函数, 无法实例化LockSupport</p> <h4 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h4> <ul><li><code>(Unsafe) unsafe.park(boolean isAbsolute, long time)</code>: 阻塞线程, time = 0表示无穷长, isAbsolute表示是否为绝对时间(即时间戳还是时间长度)</li> <li><code>(Unsafe) unsafe.unpark(Thread thread)</code>: 释放线程许可</li> <li><code>LockSupport.park()</code>: 阻塞当前线程</li> <li><code>LockSupport.park(Object blocker)</code>: 阻塞当前线程, 标识blocker为等待对象, 该函数的实现中有两次<code>setBlocker</code>, 其中第二次<code>setBlocker</code>因<code>unsafe.park()</code>而阻塞, 只有当线程再次运行时才会进行第二次<code>setBlocker</code></li> <li><code>LockSupport.parkNanos(Object blocker, long nanos)</code>: 阻塞当前线程至多nanos毫秒</li> <li><code>LockSupport.parkUntil(Object blocker, long deadline)</code>: 阻塞当前线程至多到deadline时间</li> <li><code>LockSupport.unpark(Thread thread)</code>: 给线程thread许可, 即解除thread阻塞, 若线程<code>unpark</code>, 后一次的<code>park</code>将直接跳过阻塞, 对指定线程执行<code>interrupt()</code>可以达到同样的效果</li></ul> <h4 id="比较"><a href="#比较" class="header-anchor">#</a> 比较</h4> <ul><li><code>Thread.sleep(), LockSupport.park()</code>: 不会释放占有锁</li> <li><code>Object.wait(), Condition.await()</code>: 均释放锁, 前者需要在synchronized块中使用, 后者底层调用LockSupport.park()实现阻塞</li></ul> <h3 id="threadlocal"><a href="#threadlocal" class="header-anchor">#</a> ThreadLocal</h3> <p>在不同的线程中创建独立的成员变量</p> <ul><li>如果希望ThreadLocal把某个类与线程关联起来, 则需用<code>private static</code>修饰ThreadLocal</li> <li>实现原理为利用ThreadLocalMap记录线程对应的变量值, ThreadLocalMap用数组模拟map, 且Entry使用弱引用</li> <li>线程池操作ThreadLocal时, 由于线程池不会销毁线程, ThreadLocal对应的对象不会被释放, 导致内存泄漏, 在线程结束前调用<code>ThreadLocal::remove</code>可以解决问题</li></ul> <h2 id="基本接口"><a href="#基本接口" class="header-anchor">#</a> 基本接口</h2> <h3 id="condition"><a href="#condition" class="header-anchor">#</a> Condition</h3> <p>锁的条件加锁与释放</p> <ul><li><code>await()</code>: 等待对应条件唤醒, 释放持有的锁资源</li> <li><code>awaitUninterruptibly()</code>: 即使线程被interrupted也要继续等待到条件唤醒</li> <li><code>awaitNanos(long), await(long, TimeUnit), awaitUntil(Date)</code>: <code>await()</code>限时版</li> <li><code>signal()</code>: 公平地唤醒一个等待线程, 将该线程加入AQS同步队列</li> <li><code>signalAll()</code>: 唤醒所有等待线程, 将所有线程加入AQS同步队列</li></ul> <h3 id="lock"><a href="#lock" class="header-anchor">#</a> Lock</h3> <p>JUC的锁接口</p> <ul><li><code>lock()</code>: 获取锁</li> <li><code>lockInterruptibly()</code>: 获取锁, 但当线程interrupted时不再获取锁</li> <li><code>tryLock()</code>: 锁一旦空闲就尝试获取, 即非公平锁</li> <li><code>tryLock(long, TimeUnit)</code>: <code>tryLock()</code>限时版</li> <li><code>unlock()</code>: 释放锁</li> <li><code>newCondition()</code>: 获取一个绑定当前锁的Condition实例</li></ul> <h2 id="源码细读"><a href="#源码细读" class="header-anchor">#</a> 源码细读</h2> <h3 id="锁核心类aqs-abstractqueuedsynchronizer"><a href="#锁核心类aqs-abstractqueuedsynchronizer" class="header-anchor">#</a> 锁核心类AQS(AbstractQueuedSynchronizer)</h3> <p>用来构建锁和同步器的框架, 基于CLH队列锁(虚拟的双向队列, 仅存在节点关联关系)</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// AbstractOwnableSynchronizer(AOS) 实现独占线程的保存和获取</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span> <span class="token punctuation">{</span>
  <span class="token comment">// Node为同步队列或条件队列的节点</span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token comment">// 标记为共享模式节点</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">SHARED</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 标记为独占模式节点</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">EXCLUSIVE</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 节点状态</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>
    <span class="token comment">/*
    CANCELLED,  1, 线程已取消
    SIGNAL,    -1, 线程释放锁后需唤醒后一线程
    CONDITION, -2, 线程在条件队列中
    PROPAGATE, -3, 线程后续的acquireShared可以执行
             ,  0, 默认状态
    非负状态表示节点不需要被signal, 负装填表示处于等待状态
    */</span>

    <span class="token comment">// 前驱后继节点</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>
    <span class="token comment">// 当前节点对应线程</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    <span class="token comment">// 条件队列中的下一节点</span>
    <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>

    <span class="token comment">// 空构造函数表示节点为标记节点(SHARED)或头节点</span>
    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 其余非空构造函数除了构造相应参数, 还会将当前线程设置到thread</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 同步队列头尾节点</span>
  <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>

  <span class="token comment">// 同步状态, 0表示未被锁, 大于0表示被线程重入次数</span>
  <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>

  <span class="token comment">// 同步队列为空时添加节点需要先添加一个头节点(即头节点不包含线程)</span>
  <span class="token comment">// CAS将node加入同步队列, 失败后继续尝试, 返回前驱节点</span>
  <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token comment">// 以给定模式新建节点以及当前线程加入同步队列, 返回新建节点</span>
  <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token comment">// 将node状态修改为0(除非已取消), 并LockSupport.unpark后继中第一个状态非取消的节点</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

  <span class="token comment">// 待子类实现的方法</span>
  <span class="token comment">// 独占方式尝试能否获取资源</span>
  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 独占方式尝试能否释放资源</span>
  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 共享方式尝试能否获取资源, 返回值为剩余可用资源数</span>
  <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 共享方式尝试能否释放资源</span>
  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 线程是否正在独占资源, 只有用到condition才需要实现</span>
  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 先tryAcquire获取资源, 失败后使用以独占形式加入同步队列并尝试用acquireQueued获取资源</span>
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

  <span class="token comment">// 先tryRelease尝试能否释放资源, 成功后若节点不是0状态则unparkSucessor(node)</span>
  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span> 

  <span class="token comment">// 尝试在同步队列中获取资源, 尝试失败后用shouldParkAfterFailedAcquire判断是否需要暂停线程</span>
  <span class="token comment">// 若发生异常则cancelAcquire(node)取消对资源的获取请求并暂停线程</span>
  <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token comment">// 下面的函数与acquireQueued实现基本相同</span>
  <span class="token comment">// 区别为允许中途线程暂停时停止获取资源</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token comment">// 获取资源有时间限制</span>
  <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

  <span class="token comment">// 获取共享资源有类似的函数*Shared* 但是具体实现为节点状态修改为PROPAGATE, 以及做一些共享模式下的传播</span>

  <span class="token comment">// 判断后去资源失败后是否需要暂停线程</span>
  <span class="token comment">// 如果前驱节点为头节点, 说明至多有一个线程正在占有资源</span>
  <span class="token comment">// 如果获取资源失败, 若前驱节点状态为SIGNAL, 则应当暂停线程待前驱节点唤醒</span>
  <span class="token comment">// 若前驱结点状态为取消, 则找到最近非取消前驱更新为新前驱, 继续尝试获取资源</span>
  <span class="token comment">// 若前驱结点状态为其他状态, 则更新前驱状态为SIGNAL, 因为添加了一个独占线程, 继续尝试获取资源</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> pred<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

  <span class="token comment">// 取消node获取资源的请求</span>
  <span class="token comment">// 将node状态改为CANCELLED, 若node为队尾则直接更新队列</span>
  <span class="token comment">// 否则如果node未被取消的最近前驱能修改为SIGNAL状态且不是头节点, 如果失败则说明可以让后续线程获取资源, unparkSucessor(node)</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

  <span class="token comment">// 将条件队列中的节点退队(清除nextWaiter), 以默认状态添加到同步队列中, 返回是否操作成功</span>
  <span class="token comment">// 如果同步队列原末尾节点为已取消或修改为SIGNAL状态失败, 则唤醒node的线程, 是对await的优化</span>
  <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

  <span class="token comment">// 条件队列 仅对独占模式有效</span>
  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionObject</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>
    <span class="token comment">// 条件队列头尾节点</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">,</span> lastWaiter<span class="token punctuation">;</span>
    
    <span class="token comment">// 条件队列中添加新节点, 添加前若lastWaiter已取消则unlinkCancelledWaiters()</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 将条件队列中所有已取消的节点删除, 节点的状态非CONDITION即为已取消</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 唤醒条件队列第一个节点</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 依次唤醒条件队列所有</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 加入条件队列, 暂存state值, 释放锁资源, 当节点不在同步队列时阻塞</span>
    <span class="token comment">// 进入同步队列后acquireQueued尝试获取资源, 并且做线程中断的处理措施</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 不中断的await()</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// await()限时版</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span><span class="token class-name">Date</span> deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br></div></div><h3 id="reentrantlock"><a href="#reentrantlock" class="header-anchor">#</a> ReentrantLock</h3> <p>可重入锁, 可选择公平锁或非公平锁的构造</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>
  <span class="token comment">// 实现锁的具体机制</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>

  <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>
    <span class="token comment">// 非公平尝试获取资源</span>
    <span class="token comment">// 当前线程直接尝试获取资源, 如果失败再排入同步队列</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 获取当前资源的独占线程</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> <span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 返回状态state大小</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 非公平锁, 用Sync中的nonfairTryAcquire实现tryAcquire</span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 公平锁, 新线程仅当同步队列为空时可以获取资源, 否则让队首线程先获取资源</span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="reentrantreadwritelock"><a href="#reentrantreadwritelock" class="header-anchor">#</a> ReentrantReadWriteLock</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 接口ReadWriteLock要求实现返回读锁和写锁</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLock</span> <span class="token keyword">implements</span> <span class="token class-name">ReadWriteLock</span> <span class="token punctuation">{</span>
  <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>
    <span class="token comment">// 高16位为读锁, 低16位为写锁</span>
    <span class="token comment">// 占有读锁线程数</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 占有写锁线程数</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 记录每一个读线程的读锁占用数</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HoldCounter</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 每一个线程单独的记录</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalHoldCounter</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HoldCounter</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">ThreadLocalHoldCounter</span> readHolds<span class="token punctuation">;</span>
    <span class="token comment">// 缓存上一线程的readHolds</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HoldCounter</span> cachedHoldCounter<span class="token punctuation">;</span>
    <span class="token comment">// 第一个读线程 以及占用读锁数</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Thread</span> firstReader<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> firstReaderHoldCount<span class="token punctuation">;</span>

    <span class="token comment">// 释放写锁, 返回是否完全释放写锁资源</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 获取写锁, 若当前为读锁或非当前线程占有写锁则失败, 若当前无锁但写锁需要阻塞则失败</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 释放读锁, 根据情况修改相应的变量</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 获取读锁, 若是当前线程有写锁或仅有读锁, 允许获取</span>
    <span class="token comment">// 若是读锁需要阻塞或修改读锁数失败, 则fullTryAcquireShared(Thread)重复尝试修改读锁数</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 尝试获取读锁或写锁, 无需考虑公平阻塞问题的tryAcquire和tryAcquireShared</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 非公平锁, 写锁无需阻塞, 读锁当同步队列中第一个有效请求为独占模式</span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 公平锁, 同步队列的前驱中有有效请求则读锁写锁需要阻塞</span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <h3 id="线程池作用"><a href="#线程池作用" class="header-anchor">#</a> 线程池作用</h3> <ul><li>降低资源消耗, 线程的创建与销毁</li> <li>提高响应速度, 无需创建线程</li> <li>提高线程的可管理性</li></ul> <h3 id="future接口"><a href="#future接口" class="header-anchor">#</a> Future接口</h3> <ul><li><code>cancel(boolean)</code>: 取消异步任务执行, 返回此次取消是否成功. 若任务正在执行, 参数为true时立刻中断任务且返回true, 参数为false时不会中断任务且返回true</li> <li><code>isCanceled()</code>: 判断任务是否取消</li> <li><code>isDone()</code>: 判断任务是否完成, 正常结束或发生异常均为完成</li> <li><code>get()</code>: 阻塞式获取任务结果</li> <li><code>get(long, Timeunit)</code>: <code>get()</code>限时版</li></ul> <h3 id="futuretask"><a href="#futuretask" class="header-anchor">#</a> FutureTask</h3> <ul><li><p>实现<code>Future</code>和<code>Runnable</code></p></li> <li><p>将任务分为7个状态, 其中最终态有<code>NORMAL, EXCEPTIONAL, CANCELLED, INTERRUPTED</code></p> <ol start="0"><li><code>NEW</code>: 新任务</li> <li><code>COMPLETING</code>: 执行完成但未保存结果或异常结果</li> <li><code>NORMAL</code>: 执行完成且保存结果</li> <li><code>EXCEPTIONAL</code>: 执行完成且保存异常结果</li> <li><code>CANCELLED</code>: 被用户调用<code>cancel()</code>而取消</li> <li><code>INTERRUPTING</code>: 正在中断任务</li> <li><code>INTERRUPTED</code>: 任务已中断</li></ol></li></ul> <h3 id="threadpoolexecutor"><a href="#threadpoolexecutor" class="header-anchor">#</a> ThreadPoolExecutor</h3> <p>线程集合workerSet和阻塞队列workQueue, 用户向线程池提交任务时先放入workQueue, 然后workerSet从workQueue中获取任务然后执行, 若workQueue中没有任务, worker阻塞</p> <p><strong>构造函数</strong>:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                            <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                            <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                            <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                            <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                            <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                            <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><code>corePoolSize</code>: 线程池核心线程数, 允许最大并行数</li> <li><code>maximumPoolSize</code>: 线程池允许的最多线程数, 只有当阻塞队列时有界队列时有效</li> <li><code>workQueue</code>: 等待被执行任务的阻塞队列, 使用<code>BlockingQueue</code>子类</li> <li><code>keepAliveTime</code>: 非核心线程的存活时间</li> <li><code>unit</code>: <code>keepAliveTime</code>单位</li> <li><code>threadFactory</code>: 可选, 创建线程的工厂, 默认DefaultThreadFactory</li> <li><code>handler</code>: 线程池饱和策略, 阻塞队列满时如何处理新任务, 可使用已有策略, 或自定义策略
<ul><li><code>AbortPolicy</code>: 默认, 抛出异常</li> <li><code>CallerRunsPolicy</code>: 使用调用者所在线程执行任务</li> <li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中最靠前任务</li> <li><code>DiscardPolicy</code>: 丢弃任务</li></ul></li></ul> <p><strong>线程数说明</strong>:</p> <ul><li><code>任务数&lt;=corePoolSize</code>: 由核心线程处理任务</li> <li><code>corePoolSize&lt;任务数&lt;=(corePoolSize+workQueue.size())</code>: 所有核心线程处理任务, 剩下任务放入阻塞队列</li> <li><code>(corePoolSize+workQueue.size())&lt;任务数&lt;=(maximumPoolSize+workQueue.size())</code>: 先给满核心线程, 再给满阻塞队列, 剩下的由非核心线程直接执行</li> <li><code>任务数&gt;(maximumPoolSize+workQueue.size())</code>: 处理完<code>(maximumPoolSize+workQueue.size())</code>个线程, 剩下任务根据<code>handler</code>处理</li></ul> <h4 id="executors创建"><a href="#executors创建" class="header-anchor">#</a> Executors创建</h4> <ul><li><code>newFixedThreadPool(int nThreads)</code>: 核心线程和最大线程设为nThreads, 阻塞队列为无界队列</li> <li><code>newSingleThreadExecutor()</code>: <code>newFixedThreadPool(1)</code></li> <li><code>newCachedThreadPool()</code>: 无核心线程, 线程池大小INT_MAX, 有空闲线程则取任务执行, 否则新建, 执行完任务的线程有60秒存活时间, 使用<code>SynchronousQueue</code>为阻塞队列</li> <li><code>newScheduledThreadPoolExecutor(int corePoolSize)</code>: 为任务提供延迟或周期执行, 用<code>ScheduledFutureTask</code>实现可延迟的异步计算任务, 用<code>DelayedWorkQueue</code>实现存放周期或延时任务的延迟优先队列</li></ul> <p><strong>不推荐原因</strong>:</p> <ul><li><code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>: 阻塞队列无上限可能导致OOM</li> <li><code>newCachedThreadPool</code>和<code>newScheduledThreadPool</code>: 线程池线程数最大为INT_MAX, 可能导致OOM</li></ul> <h4 id="关闭线程池"><a href="#关闭线程池" class="header-anchor">#</a> 关闭线程池</h4> <ul><li><code>shutdown</code>: 将线程池状态设为SHUTDOWN, 中断所有没有执行任务的线程</li> <li><code>shutdownNow</code>: 将线程池状态设为STOP, 停止所有正在执行或暂停任务的线程</li> <li><code>isShutDown</code>: 表示是否调用过关闭函数</li> <li><code>isTerminated</code>: 表示所有任务是否都关闭</li></ul> <h4 id="源码分析"><a href="#源码分析" class="header-anchor">#</a> 源码分析</h4> <ul><li><code>ctl: AtomicInteger</code>: 高3位存放线程池状态, 其余存放运行的worker数量
<ul><li><code>RUNNING: 111</code>: 接受新任务, 处理阻塞队列任务</li> <li><code>SHUTDOWN: 000</code>: 不接受新任务, 处理阻塞队列任务</li> <li><code>STOP: 001</code>: 不接受新任务, 不处理阻塞队列任务, 中断正在运行任务</li> <li><code>TIDYING: 010</code>: 所有任务已终止</li> <li><code>TERMINATED: 011</code>: <code>terminated()</code>方法完成</li></ul></li> <li>任务执行: <code>execute</code>决定拒绝任务或接受任务, <code>addWorker</code>创建线程并执行任务, <code>getTask</code>从阻塞队列获取任务</li> <li>任务提交: 使用<code>submit()</code>提交任务, 拿到返回的<code>Future</code>来获得线程结果</li></ul> <h3 id="forkjoinpool"><a href="#forkjoinpool" class="header-anchor">#</a> ForkJoinPool</h3> <ul><li>将大任务拆成多个小任务来异步执行的工具, 从java7开始</li> <li>两大思想: 分治, 工作窃取(work-stealing, 工作线程优先处理自身队列任务, 然后随机窃取其他队列任务)</li> <li>概要: <code>ForkJoinPool</code>通过池中的<code>ForkJoinWorkerThread</code>处理<code>ForkJoinTask&lt;T&gt;</code>任务(包括子类<code>RecursiveTask</code>, <code>RecursiveAction</code>和<code>CountedCompleter</code>)
<ul><li><code>RecursiveTask</code>: 可递归执行的有返回值的<code>RecursiveTask</code></li> <li><code>RecursiveAction</code>: 无返回值的<code>RecursiveTask</code></li> <li><code>CountedCompleter</code>: 任务完成后或发生异常后触发自定义函数</li></ul></li></ul> <p><strong>构造函数</strong>:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> parallelism<span class="token punctuation">,</span> <span class="token comment">// 并行度, 默认CPU数</span>
                    <span class="token class-name">ForkJoinWorkerThreadFactory</span> factory<span class="token punctuation">,</span> <span class="token comment">// 工作线程工厂</span>
                    <span class="token class-name">UncaughtExceptionHandler</span> handler<span class="token punctuation">,</span> <span class="token comment">// 异常处理类</span>
                    <span class="token keyword">boolean</span> asyncMode<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 是否异步, 默认false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><code>invoke(ForkJoinTask)</code>: 等待任务计算完毕并返回结果</li> <li><code>execute(ForkJoinTask)</code>: 提交异步任务, 无返回值</li> <li><code>submit(ForkJoinTask)</code>: 异步执行, 之后通过<code>ForkJoinTask.get()</code>阻塞等待结果</li> <li><code>ForkJoinTask.fork()</code>: 提交子任务, 分割任务</li> <li><code>ForkJoinTask.join()</code>: 获取子任务结果, 合并任务</li> <li><code>ForkJoinTask.invoke()</code>: 执行任务并等待结果</li></ul> <h3 id="countdownlatch"><a href="#countdownlatch" class="header-anchor">#</a> CountDownLatch</h3> <ul><li>内部有实现AQS的成员</li> <li>用于协调多线程之间的同步, 起到线程间简单通信作用, 部分线程调用<code>countDown()</code>使得计数器减1, 部分线程调用<code>await()</code>等待计数器为0结束时结束阻塞</li> <li><code>public CountDownLatch(int count)</code>: 构造给定计数初始化为count</li> <li>2种典型用法
<ol><li>某一线程运行前需要等待n个线程完成, 初始化<code>CountDownLatch(int n)</code>, n个线程执行<code>countDown()</code>, 唯一线程执行<code>await()</code></li> <li>实行多线程开始执行任务的最大并行度, 初始化<code>CountDownLatch(1)</code>, 一个线程执行<code>countDown()</code>, 多个线程执行<code>await()</code></li></ol></li></ul> <h3 id="cyclicbarrier"><a href="#cyclicbarrier" class="header-anchor">#</a> CyclicBarrier</h3> <ul><li>内部有实现AQS的成员</li> <li>让所有线程均完成后(执行到<code>CyclicBarrier.await()</code>), 所有线程才能够进行下一步操作</li> <li><code>public CyclicBarrier(int parties, Runnable barrieraction)</code>: <code>parties</code>表示参与的线程数, <code>barrieraction</code>表示最后一个完成的线程要做的操作</li> <li><code>await()</code>: 表示已经完成一部分, 需等待其他线程完成, 内部使用<code>doWait()</code>实现, 所有任务均完成后使用<code>nextGeneration()</code>重置屏障</li></ul> <h3 id="semaphore"><a href="#semaphore" class="header-anchor">#</a> Semaphore</h3> <ul><li>信号量</li> <li><code>public Semaphore(int permits, boolean fair)</code>: <code>permits</code>初始许可数, <code>fair</code>是否公平</li> <li><code>acquire()</code>: 阻塞式获取一个许可</li> <li><code>tryAcquire()</code>: 尝试获取一个许可, 返回是否成功</li> <li><code>release()</code>: 释放一个许可</li></ul> <h3 id="phaser"><a href="#phaser" class="header-anchor">#</a> Phaser</h3> <ul><li><code>CyclicBarrier</code>可以动态修改<code>party</code>且能控制是否阻塞版</li> <li><code>register()</code>: 注册一个新的<code>party</code></li> <li><code>bulkRegister(int parties)</code>: 批量注册<code>party</code></li> <li><code>arrive()</code>: 到达且不等待其他任务到达, 返回<code>phase number</code></li> <li><code>arriveAndDeregister()</code>: 到达并取消注册, 返回<code>phase number</code></li> <li><code>arriveAndAwaitAdvance()</code>: 到达且等待其他任务到达, 返回<code>phase number</code></li> <li><code>awaitAdvance(int phase)</code>: 阻塞到当前<code>phaser</code>变为<code>phase</code></li> <li><code>state</code>: 低16位表示未到达<code>parties</code>数, 中16-31位表示等待的<code>parties</code>数, 中32-62位表示<code>phase number</code>当前代(每到达1次加1), 63位表示当前<code>phaser</code>的终止状态</li></ul> <h3 id="exchanger"><a href="#exchanger" class="header-anchor">#</a> Exchanger</h3> <ul><li>两个线程之间交换数据, 第一个到达的线程在slot中放入数据, 阻塞等待, 第二个线程到达后读取存入数据, 交换数据, 唤醒第一个线程</li> <li><code>V exchange(V x)</code>: <code>x</code>为要交换的数据, 返回值为交换得到的数据</li> <li>内部使用<code>arena</code>数组降低竞争</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">2022/11/1 10:20:27</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/camille/java/theory/multi_process/basic.html" class="prev">
        理论基础
      </a></span> <span class="next"><a href="/camille/java/theory/jvm/basic.html">
        理论基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/camille/assets/js/app.89cf657d.js" defer></script><script src="/camille/assets/js/2.c0d8e570.js" defer></script><script src="/camille/assets/js/1.b1971c90.js" defer></script><script src="/camille/assets/js/40.665ccab0.js" defer></script>
  </body>
</html>
